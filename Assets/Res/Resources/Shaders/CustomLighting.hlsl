#ifndef CUSTOM_LIGHTING_INCLUDED
#define CUSTOM_LIGHTING_INCLUDED

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

// Substance's specular occlusion
float SpecularOcclusionCorrection(float diffuseOcclusion, float metallic, float roughness)
{
    return lerp(diffuseOcclusion, 1.0, metallic * (1.0 - roughness) * (1.0 - roughness));
}

half GetDielectricSpec(half specularLevel)
{
    return 0.08 * specularLevel;
}

half3 ComputeF0(half specular, half3 baseColor, half metallic)
{
    return lerp(GetDielectricSpec(specular).xxx, baseColor, metallic);
}

inline float GGXTerm(float NdotH, float roughness)
{
    float a2 = roughness * roughness;
    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad
    return INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,
    // therefore epsilon is smaller than what can be represented by half
}
float GGXTermAppro(float NdH, float roughness)
{
    float a2 = roughness * roughness;
    float d = (NdH * a2 - NdH) * NdH + 1.0f;
    return INV_PI * a2 / (d * d + 1e-7f);
}

half3 EnvBRDFApprox( half3 specColor, half roughness, half NdV )
{
    half4 c0 = { -1, -0.0275, -0.572, 0.022 };
    half4 c1 = { 1, 0.0425, 1.04, -0.04 };
    half4 r = roughness * c0 + c1;
    half a004 = min( r.x * r.x, exp2( -9.28 * NdV) ) * r.x + r.y;
    half2 AB = half2( -1.04, 1.04 ) * a004 + r.zw;

    AB.y *= saturate( 50.0 * specColor.g );

    return specColor * AB.x + AB.y;
}

inline half3 DiffSpecFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)
{
    specColor = lerp (kDieletricSpec.rgb, albedo, metallic);
    oneMinusReflectivity = (1 - metallic)*kDieletricSpec.a;
    return albedo * oneMinusReflectivity;
}

half3 GetIndirectSpec(TEXTURECUBE_PARAM(cubeMap, sampler_cubeMap), half4 hdrParam, half3 reflectDir, half perceptualRoughness, half occlusion)
{
#if !defined(_ENVIRONMENTREFLECTIONS_OFF)
    half mip = (1.7 - perceptualRoughness*0.7)*perceptualRoughness*6;
    half4 encodedIrradiance = SAMPLE_TEXTURECUBE_LOD(cubeMap, sampler_cubeMap, reflectDir, mip);

#if !defined(UNITY_USE_NATIVE_HDR)
    real alpha = max(hdrParam.w * (encodedIrradiance.a - 1.0) + 1.0, 0.0);
    half3 irradiance = (hdrParam.x * PositivePow(alpha, hdrParam.y)) * encodedIrradiance.rgb;
#else
    half3 irradiance = encodedIrradiance.rgb;
#endif
    return irradiance * occlusion;
#endif // GLOSSY_REFLECTIONS

    return _GlossyEnvironmentColor.rgb * occlusion;
}
half3 CustomGetIndirectSpec(TEXTURECUBE_PARAM(cubeMap, sampler_cubeMap), half perceptualRoughness, half3 reflectDir)
{
    half mip = (1.7 - perceptualRoughness*0.7)*perceptualRoughness*8;
    half4 reflectColor = SAMPLE_TEXTURECUBE_LOD(cubeMap, sampler_cubeMap, reflectDir, mip);
    //reflectColor.xyz = DecodeHDR(reflectColor, _IBLMap_HDR);
    reflectColor.xyz = reflectColor.xyz*reflectColor.w;
    return reflectColor.xyz;
}

half3 IndirectBRDF(half3 diffColor, half3 specColor, half3 indirectDiff, half3 indirectSpec, half roughness2, half grazingTerm, half fresnelTerm)
{
    half3 c = indirectDiff * diffColor;
    float surfaceReduction = 1.0 / (roughness2 + 1.0);
    c += surfaceReduction * indirectSpec * lerp(specColor, grazingTerm, fresnelTerm);
    return c;
}

half3 DirectBRDF(Light light, half3 normalWS, half3 viewDirWS, half roughness, half roughness2, half3 diffColor, half3 specColor)
{
    half3 lightColor = light.color;
    half3 lightDirWS = light.direction;
    half lightAttenuation = light.distanceAttenuation * light.shadowAttenuation;
    half NdL = saturate(dot(normalWS, lightDirWS));
    half3 radiance = lightColor * (lightAttenuation * NdL);    
    
    half3 color;
#ifndef _SPECULARHIGHLIGHTS_OFF
    float3 halfDir = SafeNormalize(float3(lightDirWS) + float3(viewDirWS));
    float NdH = saturate(dot(normalWS, halfDir));
    half LdH = saturate(dot(lightDirWS, halfDir));
    float d = NdH * NdH * (roughness2-1) + 1.00001f;
    half specularTerm = roughness2 / ((d * d) * max(0.1h, LdH * LdH) * (roughness*4 + 2));
#if defined (SHADER_API_MOBILE) || defined (SHADER_API_SWITCH)
    specularTerm = specularTerm - HALF_MIN;
    specularTerm = clamp(specularTerm, 0.0, 100.0); // Prevent FP16 overflow on mobiles
#endif
    color = specularTerm * specColor + diffColor;
#else
    color = diffColor;
#endif

    color *= radiance;
    
    return color;
}

half3 GetSSSColor(half halfLambert, half rate, TEXTURE2D_PARAM(skinMap, skinSampler), half3 worldNormal, half3 worldPos)
{
    //BRDF Tex
    half2 sssUV;
    sssUV.x = halfLambert;
    //The curve can be replace by one texture channel generated by Houdini DCC tool.
    sssUV.y = saturate(rate * (length(fwidth(worldNormal)) / length(fwidth(worldPos))));

    half3 sssColor = SAMPLE_TEXTURE2D(skinMap, skinSampler, sssUV).xyz;
    return sssColor;
}

half3 GetBakedSpec(half3 illuminance, real4 direction, half3 normalWS, half3 viewDirWS, half3 specColor, half perceptualRoughness, half roughness)
{
    real3 bakedLightDir = (direction.xyz - 0.5)*2;
    real bakedLightFactor = length(bakedLightDir);
    bakedLightDir = normalize(bakedLightDir.xyz/max(0.001, bakedLightFactor));
    half bakedNdl = dot(normalWS,bakedLightDir);
    real3 bakedLightColor = bakedLightFactor*illuminance/max(0.1,bakedNdl);
    real3 bakedHalfDir = SafeNormalize(viewDirWS + bakedLightDir);
    half3 bakedSpec = specColor*(perceptualRoughness*0.25+perceptualRoughness)*GGXTerm(saturate(dot(normalWS, bakedHalfDir)),roughness);
    bakedSpec *= PI*bakedLightColor*bakedNdl;
    return bakedSpec;
}
float GetNormalizedDist(float worldPosY,float MaxBorderY,float MinBorderY)
{
	float range = MaxBorderY - MinBorderY;
	float border = MaxBorderY;

	float dist = abs(worldPosY - border);
	float normalizedDist = saturate(dist / range);
	return normalizedDist;
}

float GetCutout(half4 DissolveTex,half3 WorldPosition,half Dissolve,half DistanceEffect,half MaxBorderY,half MinBorderY)
{
    //half4 Dissolution = SAMPLE_TEXTURE2D(_DissolveTex,sampler_DissolveTex,IN.uv2);
    //half4 Ramtex = SAMPLE_TEXTURE2D(_RampTex,sampler_RampTex,IN.uv);
    half Dissolution = saturate(DissolveTex).x;              
    float dissolveEdge = step(0, WorldPosition.y-Dissolve-0.01);
    float normalizedDist = GetNormalizedDist(WorldPosition.y,MaxBorderY,MinBorderY);
	float cutout = Dissolution.r * (1 - DistanceEffect) + normalizedDist * DistanceEffect;
    float edgeCutout = cutout-Dissolve;
    return edgeCutout;

}
// real3 CustomSampleDirectionalLightmap(TEXTURE2D_PARAM(lightmapTex, lightmapSampler), TEXTURE2D_PARAM(lightmapDirTex, lightmapDirSampler), float2 uv, float4 transform, float3 normalWS, bool encodedLightmap, real4 decodeInstructions, out real4 direction)
// {
//     // transform is scale and bias
//     uv = uv * transform.xy + transform.zw;
//
//     direction = SAMPLE_TEXTURE2D(lightmapDirTex, lightmapDirSampler, uv);
//     // Remark: baked lightmap is RGBM for now, dynamic lightmap is RGB9E5
//     real3 illuminance = real3(0.0, 0.0, 0.0);
//     if (encodedLightmap)
//     {
//         real4 encodedIlluminance = SAMPLE_TEXTURE2D(lightmapTex, lightmapSampler, uv).rgba;
//         illuminance = DecodeLightmap(encodedIlluminance, decodeInstructions);
//     }
//     else
//     {
//         illuminance = SAMPLE_TEXTURE2D(lightmapTex, lightmapSampler, uv).rgb;
//     }
//     real halfLambert = dot(normalWS, direction.xyz - 0.5) + 0.5;
//
//     // AHD
//     real3 mainLightDir = (direction.xyz - 0.5)*2;
//     real mainLightFactor = length(mainLightDir);
//     mainLightDir = normalize(mainLightDir.xyz/max(0.001, mainLightFactor));
//     real3 mainLightColor = mainLightFactor*illuminance/max(0.1,dot(normalWS,mainLightDir));
//
//     real3 halfDir = normalize(viewDirWS + mainLightDir);
//     real NdH = saturate(dot(normalWS, halfDir));
//     real3 specularColor = pow(max(NdH, 0.0001), 100)*mainLightColor;
//     
//     return illuminance * halfLambert / max(1e-4, direction.w) + specularColor;
// }
// real3 CustomSampleSingleLightmap(TEXTURE2D_PARAM(lightmapTex, lightmapSampler), float2 uv, float4 transform, bool encodedLightmap, real4 decodeInstructions)
// {
//     // transform is scale and bias
//     uv = uv * transform.xy + transform.zw;
//     real3 illuminance = real3(0.0, 0.0, 0.0);
//     // Remark: baked lightmap is RGBM for now, dynamic lightmap is RGB9E5
//     if (encodedLightmap)
//     {
//         real4 encodedIlluminance = SAMPLE_TEXTURE2D(lightmapTex, lightmapSampler, uv).rgba;
//         illuminance = DecodeLightmap(encodedIlluminance, decodeInstructions);
//     }
//     else
//     {
//         illuminance = SAMPLE_TEXTURE2D(lightmapTex, lightmapSampler, uv).rgb;
//     }
//     return illuminance;
// }

half3 CustomSampleLightmap(float2 uv, half3 normalWS, out real4 direction)
{
#ifdef UNITY_LIGHTMAP_FULL_HDR
    bool encodedLightmap = false;
#else
    bool encodedLightmap = true;
#endif
    
    direction = real4(0,0,0,0);
    half4 decodeInstructions = half4(LIGHTMAP_HDR_MULTIPLIER, LIGHTMAP_HDR_EXPONENT, 0.0h, 0.0h);
    half4 transformCoords = half4(1, 1, 0, 0);
    
#ifdef DIRLIGHTMAP_COMBINED
    // transform is scale and bias
    uv = uv * transformCoords.xy + transformCoords.zw;
    direction = SAMPLE_TEXTURE2D(unity_LightmapInd, samplerunity_Lightmap, uv);
    // Remark: baked lightmap is RGBM for now, dynamic lightmap is RGB9E5
    real3 illuminance = real3(0.0, 0.0, 0.0);
    if (encodedLightmap)
    {
        real4 encodedIlluminance = SAMPLE_TEXTURE2D(unity_Lightmap, samplerunity_Lightmap, uv).rgba;
        illuminance = DecodeLightmap(encodedIlluminance, decodeInstructions);
    }
    else
    {
        illuminance = SAMPLE_TEXTURE2D(unity_Lightmap, samplerunity_Lightmap, uv).rgb;
    }
    return illuminance;
    //real halfLambert = dot(normalWS, direction.xyz - 0.5) + 0.5;
    //return illuminance * halfLambert / max(1e-4, direction.w);
#elif defined(LIGHTMAP_ON)
    // transform is scale and bias
    uv = uv * transformCoords.xy + transformCoords.zw;
    real3 illuminance = real3(0.0, 0.0, 0.0);
    // Remark: baked lightmap is RGBM for now, dynamic lightmap is RGB9E5
    if (encodedLightmap)
    {
        real4 encodedIlluminance = SAMPLE_TEXTURE2D(unity_Lightmap, samplerunity_Lightmap, uv).rgba;
        illuminance = DecodeLightmap(encodedIlluminance, decodeInstructions);
    }
    else
    {
        illuminance = SAMPLE_TEXTURE2D(unity_Lightmap, samplerunity_Lightmap, uv).rgb;
    }
    return illuminance;
#else
    return half3(0.0, 0.0, 0.0);
#endif
}
#endif